**Подвиг 1.** Выберите все верные утверждения, касающиеся проблем использования базовых функций и операторов выделения/освобождения памяти на языке C/C++.

* (-)на одну и ту же область памяти ссылается несколько указателей

* (+)память не была выделена, но в нее выполняется запись данных

* (+)память была выделена, но не освобождена (утечка памяти)

* (+)попытка несколько раз освободить одну и ту же область памяти

* (+)память была освобождена, но работа с ней продолжается так, словно она остается выделенной

**Подвиг 2.** Выберите все верные утверждения, касающиеся smart-указателей языка С++.

* (+)класс unique_ptr определяет smart-указатель, который в единственном числе может ссылаться на определенную, выделенную область памяти

* (-)класс shared_ptr определяет smart-указатель, который в единственном числе может ссылаться на определенную, выделенную область памяти

* (-)класс unique_ptr определяет smart-указатель, который во множественном числе может ссылаться на одну и ту же выделенную область памяти

* (+)класс shared_ptr определяет smart-указатель, который во множественном числе может ссылаться на одну и ту же выделенную область памяти

* (+)для использования smart-указателей в программе необходимо подключить заголовок memory

* (+)как только указатель unique_ptr перестает существовать, область памяти на которую он ссылается, автоматически освобождается


**Подвиг 3.** Выберите все верные утверждения, касающиеся следующей программы:

* (+)указатель ptr_1 ссылается на тип данных point и принимает значение nullptr

* (-)указатель ptr_2 ссылается на объект типа point, созданный с помощью функции make_unique

* (+)указатель ptr_3 ссылается на объект типа point, созданный с помощью оператора new

* (+)при выполнении команды ptr_3 = std::make_unique<point>(); прежняя область памяти автоматически освобождается

* (+)при выполнении команды ptr_3 = std::make_unique<point>(); произойдет "утечка" памяти

* (+)для указателей unique_ptr создание объектов рекомендуется выполнять с помощью функции make_unique

* (+)команда ptr_2 = ptr_3; приведет к ошибке, т.к. один указатель типа unique_ptr не может быть присвоен другому такому же указателю


**Подвиг 8 (на повторение).** Выберите все верные утверждения, касающиеся следующей программы:

#include <iostream>
#include <fstream>

using std::ios;

int main()
{
    short marks[] = {3, 3, 4, 3, 2, 2};

    std::ofstream ofs("my_data.dat", ios::out | ios::binary);

    if(!ofs) {
        std::cout << "Невозможно открыть файл";
        return 1;
    }

    ofs << "hello" << std::endl;
    ofs.write((char *)marks, sizeof(marks) / sizeof(*marks));

    ofs.close();
    return 0;
}

* (+)метод (функция) write побайтно записывает массив marks в файл my_data.dat

* (-)команда ofs << "hello" приведет к ошибке, т.к. файл открыт в бинарном режиме

* (+)если после записи не закрыть файловый поток, то данные в файл могут полностью не записаться (произойдет потеря данных)

* (+)приведение типов (char *)marks необходимо, т.к. первый параметр метода write ожидает указатель типа const char*

* (+)работа с файлом my_data.data выполняется в бинарном режиме

* (+)команда ofs << "hello" записывает строку "hello" в файл my_data.dat