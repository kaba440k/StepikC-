**Подвиг 1.** Выберите все верные утверждения, касающиеся создания объектов структур в языке С++.

* (+)при создании объектов-структур в виде обычных переменных (например, point pt;) компилятор языка С++ автоматически добавляет в код вызов конструктора и деструктора

* (+)при динамическом удалении объектов-структур с помощью оператора delete (например, delete pt;) компилятор языка С++ автоматически добавляет в код вызов деструктора

* (-)при динамическом удалении объектов-структур с помощью функции free (например, free(pt);) компилятор языка С++ автоматически добавляет в код вызов деструктора

* (+)при динамическом создании объектов-структур с помощью оператора new (например, point* pt = new point;) компилятор языка С++ автоматически добавляет в код вызов конструктора

* (-)при динамическом создании объектов-структур с помощью функции malloc (например, point* pt = (point *)malloc(sizeof(point));) компилятор языка С++ автоматически добавляет в код вызов конструктора


**Подвиг 4.** Предположим, что статический массив создан командой:

double *ptr_d = new double[10];
Выберите правильную команду для освобождения памяти из под этого массива.


* (-)delete(ptr_d);

* (-)delete[] *ptr_d;

* (-)delete(*ptr_d);

* (-)delete *ptr_d;

* (-)delete ptr_d;

* (+)delete[] ptr_d;


**Подвиг 8 (на повторение).** Выберите все верные утверждения, касающиеся захвата переменных лямбда-выражениями.

* (+)при захвате массива int d[10]; [d] ([параметры]) mutable {[операторы]} изменение значений его элементов в лямбда-функции не приведет к изменению внешнего массива d

* (+)выполнение выражение вида [a, b] ([параметры]) mutable { a++; --b; } приведет к изменению переменных a и b только внутри лямбда-функции и не затронет внешние локальные переменные a и b

* (+)выполнение выражение вида [var_i]([параметры]) {var_i += 1;} приведет к ошибке, т.к. переменная var_i является константной

* (+)выражение вида [=]([параметры]) {[операторы]} позволяет в теле лямбда-функции только читать значения из копий любых локальных переменных

* (-)при захвате массива int d[10]; [d] ([параметры]) mutable {[операторы]} изменение значений его элементов в лямбда-функции приведет также к изменению внешнего массива d

* (-)выполнение выражение вида [a, b] ([параметры]) mutable { a++; --b; } приведет к изменению переменных a и b и это изменение затронет внешние локальные переменные a и b


**Подвиг 9 (на повторение).** Пусть в программе имеются следующие локальные переменные:

char msg[] = "hello";
int count = 0;
int& lnk = count;
char* ptr = msg;

Выберите все верные (работающие) варианты объявления лямбда-выражений.

* (+)auto lmd_3 = [&count] (int step) { count += step; };

* (-)auto lmd_6 = [*ptr] (int step) { *ptr += step; };

* (+)auto lmd_2 = [=] () { std::cout << msg; };

* (-)auto lmd_7 = [lnk] (int step) { lnk += step; };

* (+)auto lmd_1 = [msg, count, lnk, ptr] () { return count + 1; };

* (+)auto lmd_4 = [&lnk] (int step) { lnk += step; };

* (+)auto lmd_5 = [ptr] (int step) { *ptr += step; };


**Подвиг 10 (на повторение).** Выберите все верные утверждения, касающиеся следующего фрагмента программы:

int module_id = -1;

namespace params {
int global_result = 0;
}

namespace triangle {
double square(int a, int b, int c)
{
    double p = (a+b+c) / 2.0;
    return sqrt(p*(p-a)*(p-b)*(p-c));
}
}

namespace params {
typedef union {
    int res_int;
    double res_dbl;
} RESULT;
}

* (-)в пространстве params будет содержаться только тип RESULT

* (+)обращение к переменной module_id в теле функций можно записывать в виде module_id или в виде ::module_id

* (+)обращение к типу RESULT следует записывать в виде params::RESULT

* (+)обращение к функции square следует прописывать в виде triangle::square

* (+)символ :: называется символом раскрытия области видимости

* (+)в пространстве params описана переменная global_result и тип RESULT

* (+)в пространстве triangle присутствует функция с именеме square

* (-)в пространстве имен нельзя определять типы данных, поэтому последнее определение params приведет к ошибке