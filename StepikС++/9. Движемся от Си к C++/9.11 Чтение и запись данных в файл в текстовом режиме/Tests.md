# 9.11 Чтение и запись данных в файл в текстовом режиме

**Подвиг 1.** Выберите все верные утверждения, связанные со следующей программой.

#include <iostream>
#include <fstream>

using std::ifstream;
using std::ofstream;

int main()
{
    ofstream fs("my_marks.dat");

    if(!fs) {
        std::cout << "Невозможно открыть файл";
        return 0;
    }

    short marks[] = {3, 3, 2, 3, 4, 3, 2};
    for(int i = 0; i < sizeof(marks) / sizeof(*marks); ++i)
        fs << marks[i] << "; ";

    fs.close();

    return 0;
}


* (+)после успешного выполнения программы файл my_marks.dat будет содержать строку: 3; 3; 2; 3; 4; 3; 2;

* (-)открывается файл на дозапись с именем my_marks.dat в текущем (рабочем) каталоге

* (+)в файл my_marks.dat происходит запись значений из массива marks

* (+)открывается файл на запись с именем my_marks.dat в текущем (рабочем) каталоге

* (-)после успешного выполнения программы файл my_marks.dat будет содержать строку: 3; 3; 2; 3; 4; 3; 2

* (+)если файловый поток не был открыт, то в консоль выводится сообщение "Невозможно открыть файл" и функция main завершает свою работу


**Подвиг 2.** Выберите все верные утверждения, связанные со следующей программой.

#include <iostream>
#include <fstream>

using std::ifstream;
using std::ofstream;

int main()
{
    ifstream fs("my_marks.dat");

    if(!fs) {
        std::cout << "Невозможно открыть файл";
        return 0;
    }

    short marks[10] = {0};
    int count = 0;
    while(count < 10 && fs >> marks[count])
        count++;

    fs.close();

    for(const int& x : marks)
        std::cout << x << " ";

    return 0;
}

* (+)в цикле while выполняется последовательное чтение данных, пока не будет прочитано 10 элементов, или операция чтения >> не вернет значение 0

* (+)в конце программы выполняется поэлементный вывод значений всех элементов массива marks

* (+)открывается файл на чтение с именем my_marks.dat в текущем (рабочем) каталоге

* (-)в конце программы выполняется поэлементный вывод только прочитанных из файла значений элементов массива marks

* (+)если в файле my_marks.dat присутствует строка "3; 3; 2; 3; 4; 3; 2; ", то будет прочитано только первое число из этого файла

* (-)если в файле my_marks.dat присутствует строка "3; 3; 2; 3; 4; 3; 2; ", то будут прочитаны все числа из этого файла


**Подвиг 3.** Имеется следующая программа:

#include <iostream>
#include <fstream>

using std::ifstream;
using std::ofstream;

int main()
{
    short sh = 10;
    double d = -0.56;
    char ch = 'a';
    
    ofstream ofs("my_data.dat");

    if(!ofs) {
        std::cout << "Невозможно открыть файл";
        return 0;
    }

    // здесь будет располагаться записанная команда

    ofs.close();

    return 0;
}
Запишите в одну строчку команду для записи значений переменных sh, d, ch (именно в таком порядке) в файловый поток ofs в одну строчку через пробел.

* Напишите текст
    * ofs<<sh<<" "<<d<<" "<<ch;


**Подвиг 4.** Имеется следующая программа:

#include <iostream>
#include <fstream>

using std::ifstream;
using std::ofstream;

int main()
{
    short sh;
    double d;
    char ch;
    
    ifstream ifs("my_data.dat");

    if(!ifs) {
        std::cout << "Невозможно открыть файл";
        return 0;
    }

    // здесь будет располагаться записанная команда

    ifs.close();

    return 0;
}
Запишите в одну строчку команду для чтения значений в переменные sh, d, ch (именно в таком порядке) из файлового потока ifs (данные записаны в одну строчку через пробел).
* Напишите текст
    * ifs>>sh>>d>>ch;


**Подвиг 5.** Пусть в программе открыт файловый поток ifs на чтение данных из файла my_life.txt. Запишите команду для чтения из этого файла первой строки (целиком) в переменную:

std::string header;
Используйте для этого функцию getline. В конце не забудьте поставить точку с запятой.

* Напишите текст
    * getline(ifs, header);


**Подвиг 6.** Пусть в программе открыт файловый поток fs на запись данных в файл my_life.txt. Запишите команду для записи в этот файл строки:

std::string header {"Краткая история языка С++"};
В конце не забудьте записать в файл перенос на новую строку с помощью функции std::endl.

* Напишите текст
    * fs<<header<<std::endl;

**Подвиг 7 (на повторение).** Установите соответствия между функциями языка Си и их описаниями.

* perror() - отображение последней возникшей ошибки при работе с потоками ввода/вывода
* fseek() - изменение положения позиции указателя в потоке ввода/вывода
* ftell() - получение текущего положения позиции указателя в потоке ввода/вывода
* fgetc() - чтение одного байта из указанного потока
* fputc() - запись одного байта в указанный поток


**Подвиг 8 (на повторение).** Выберите все верные утверждения, касающиеся потоков ввода/вывода языка Си.

* (+)предопределенное значение EOF означает конец данных в файловом потоке

* (+)для использования макроса errno необходимо подключить заголовочный файл errno.h

* (+)макрос errno содержит код последней возникшей ошибки при работе с потоками ввода/вывода

* (-)функции perror, fseek, ftell определены в заголовочном файле stdfile.h

* (+)функции perror, fseek, ftell определены в заголовочном файле stdio.h

* (-)для использования макроса errno необходимо подключить заголовочный файл stdio.h


**Подвиг 9 (на повторение).** Установите соответствия между константами и их описаниями.

* SEEK_SET - установка файловой позиции относительно начала файла
* SEEK_CUR - установка файловой позиции относительно текущей позиции
* SEEK_END - установка файловой позиции относительно конца файла





