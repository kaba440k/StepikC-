**Подвиг 1.** Выберите все верные утверждения, касающиеся бинарного режима работы с файлами в С++.

* (+)в бинарном режиме данные записываются и читаются из файлов один в один без каких-либо искажений и пропусков

* (+)для чтения данных в бинарном режиме применяется метод (функция) read

* (-)для чтения данных в бинарном режиме применяется метод (функция) write

* (+)для записи данных в бинарном режиме применяется метод (функция) write

* (+)для открытия файлового потока в бинарном режиме следует указать флаг ios::binary

* (-)для записи данных в бинарном режиме применяется метод (функция) read


**Подвиг 2.** Выберите все верные утверждения, касающиеся следующей программы:

#include <iostream>
#include <fstream>

using std::ios;

int main()
{
    short marks[] = {3, 3, 4, 3, 2, 2};

    std::ofstream ofs("my_data.dat", ios::out | ios::binary);

    if(!ofs) {
        std::cout << "Невозможно открыть файл";
        return 1;
    }

    ofs << "hello" << std::endl;
    ofs.write((char *)marks, sizeof(marks));

    ofs.close();
    return 0;
}

* (+)команда ofs << "hello" записывает строку "hello" в файл my_data.dat

* (+)метод (функция) write побайтно записывает массив marks в файл my_data.dat

* (+)приведение типов (char *)marks необходимо, т.к. первый параметр метода write ожидает указатель типа const char*

* (+)если после записи не закрыть файловый поток, то данные в файл могут полностью не записаться (произойдет потеря данных)

* (-)команда ofs << "hello" приведет к ошибке, т.к. файл открыт в бинарном режиме

* (+)работа с файлом my_data.data выполняется в бинарном режиме


**Подвиг 3.** Запишите комбинированный флаг для открытия файлового потока на чтение в бинарном режиме.

* Напишите текст
    * std::ios::in | std::ios::binary


**Подвиг 4.** Пусть имеется следующая программа:

#include <iostream>
#include <fstream>

using std::ios;

int main()
{
    short marks[10];

    std::ifstream ifs("my_data.dat", ios::in | ios::binary);

    // здесь будет располагаться записанная команда (оператор)

    ifs.close();

    return 0;
}
Запишите команду (оператор) для побайтного считывания данных (записанных в бинарном виде) из файлового потока ifs в массив marks. Максимальный размер читаемых данных не должен превышать байтового размера массива marks.

* Напишите текст
    * ifs.read((char *)marks, sizeof(marks));


**Подвиг 5.** Пусть имеется следующая программа:

#include <iostream>
#include <fstream>

using std::ios;

int main()
{
    double digits[10] = {0.5, 0.3, 0.6};
    int count = 3;

    std::ofstream ofs("digits.dat", ios::out | ios::binary);

    // здесь будет располагаться записанная команда (оператор)

    ofs.close();

    return 0;
}
Запишите команду (оператор) для побайтной записи данных (в бинарном режиме) в файловый поток ofs первых count значений массива digits.

* Напишите текст
    * ofs.write((char*)digits, sizeof(double) * count);


**Подвиг 6.** Продолжите программу:

#include <iostream>
#include <fstream>

struct car {
    char model[50];
    unsigned short max_speed;
    double power;
    unsigned int weight;
};

int main()
{
    car my_auto = {"BMW X5", 240, 215.6, 1743};
    std::ofstream ofs("autos.db", std::ios::out | std::ios::binary);

    // здесь будет располагаться записанная команда (оператор)

    ofs.close();
    return 0;
}
Запишите команду (оператор) для побайтной записи переменной my_auto (в бинарном режиме) в файловый поток ofs.

* Напишите текст
    * ofs.write((char *)&my_auto, sizeof(car));


**Подвиг 7.** Продолжите программу:

#include <iostream>
#include <fstream>

struct car {
    char model[50];
    unsigned short max_speed;
    double power;
    unsigned int weight;
};

int main()
{
    car my_auto;
    std::ifstream ifs("autos.db", std::ios::in | std::ios::binary);

    // здесь будет располагаться записанная команда (оператор)

    ifs.close();
    return 0;
}
Запишите команду (оператор) для побайтного чтения данных (записанных в бинарном режиме) из файлового потока ifs в переменную my_auto.

* Напишите текст
    * ifs.read((char *)&my_auto, sizeof(car));


**Подвиг 8 (на повторение).** Установите соответствия между режимами доступа и их описаниями.

* ios::in - для чтения (только для объектов классов ifstream или fstream)
* ios::out - для записи; прежние данные удаляются (только для объектов классов ofstream или fstream)
* ios::app - для дозаписи; прежние данные не удаляются
* ios::ate - при открытии указатель файла смещается в конец
* ios::binary - открытие файла в бинарном режиме доступа


**Подвиг 9 (на повторение).** Выберите все верные (работающие) конструкции с константной переменной языка C++.


* (-)const char ch_cnst; ch_cnst = 12;

* (-)const int var;

* (-)char const cnst_ch; cnst_ch = 12;

* (+)const int a = 5; int b = a;

* (+)long const lg = 10;

* (+)const short sh = 100;


**Подвиг 10 (на повторение).** Выберите все верные утверждения, касающиеся следующего фрагмента программы языка Си стандарта C99:

#include <stdio.h>

int main(void)
{
    int n = 7;
    while(n-- > 0) {
        int n = 5;
        printf("%d\n", n);
        n++;
    }
    
    printf("%d\n", n);

    return 0;
}

* (+)цикл while сработает ровно семь раз (семь итераций)

* (-)при выполнении программы в консоли шесть раз отобразится число 5, а в конце число -1

* (+)при выполнении программы в консоли семь раз отобразится число 5, а в конце число -1

* (-)цикл while будет работать "вечно", т.к. значение n на каждой итерации устанавливается равным 5

* (-)при выполнении программы в консоли восемь раз отобразится число 5, а в конце число 0

* (+)в теле цикла while переменная n каждый раз инициализируется значением 5