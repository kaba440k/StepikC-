**Подвиг 1.** Выберите все верные утверждения, касающиеся перегрузки функций в языке С++.

* (+)выбор вызова той или иной перегруженной функции выполняется компилятором в момент компиляции программы

* (+)перегрузку функций можно отнести к одному из видов статического полиморфизма (ad hoc полиморфизм)

* (+)функции называются перегруженными, если они имеют одинаковое имя, но разные типы и/или количество входных параметров

* (-)выбор вызова той или иной перегруженной функции выполняется в соответствии с типами входных аргументов в процессе работы программы

* (-)перегрузку функций можно отнести к одному из видов динамического полиморфизма (dynamic полиморфизм)


**Подвиг 2.** Пусть в программе изначально объявлена следующая функция:

int func_overload(int x) {return 0;}
Выберите все верные варианты, соответствующие ее перегрузке.

* (+)int func_overload(unsigned int x) {return 7;}

* (-)int func_overload(int y) {return 4;}

* (+)int func_overload(int x, int y) {return 1;}

* (-)int func_overload(const int x) {return 6;}

* (-)double func_overload(int x) {return 3;}

* (+)int func_overload(double x) {return 2;}

* (+)int func_overload(short x) {return 5;}


**Подвиг 3.** Пусть в программе объявлены следующие перегруженные функции:

int perimetr(unsigned a, unsigned b)
{
    return 2 * (a + b);
}

float perimetr(float a, float b)
{
    return 2.0f * (a + b);
}
Отметьте для каждого вызова номер вызываемой функции (1 - первая; 2 - вторая), либо ошибку вызова.

* (ошибка)int res_1 = perimetr(10, 20);	


* (ошибка)float res_2 = perimetr(10, 20);	


* (2)float res_3 = perimetr(10.0f, 20.0f);	


* (1)int res_4 = perimetr(10u, 20u);	


* (1)float res_5 = perimetr(10u, 20u);	


* (ошибка)float res_6 = perimetr(10.0, 20.0);	


* (2)double res_7 = perimetr(10.0f, 20.0f);	


**Подвиг 7.** Выберите все верные утверждения, касающиеся директивы extern "C" языка С++.

* (+)директива extern "C" указывает компилятору С++ воспринимать (находить, определять) метку функции в объектных файлах исключительно по ее имени

* (+)из-за введения механизма перегрузки имен функций в С++ их метки в объектных файлах представляются именем функции и набором типов параметров

* (+)внутри директивы extern "C" нельзя прописывать перегрузку функций

* (+)директива extern "C" указывает компилятору С++ кодировать метку функции в объектных файлах исключительно по ее имени (без набора типов параметров)

* (+)в программах на С++ доступно и предопределено макроимя __cplusplus, а в языке Си изначально его нет

* (+)компилятор языка Си не воспринимает директиву extern "C" и ее наличие приведет к синтаксической ошибке


**Подвиг 10 (на повторение).** Имеется следующая программа:

#define TOTAL   1024

int main(void)
{
    int total = 100;
    // здесь выполняются объявления

    return 0;
}
Выберите все верные (рабочие) варианты объявления массивов внутри функции main().


* (-)long ar_5[0];

* (+)double ar_2[5 * 3 - 2];

* (+)unsigned short ar_1[100];

* (+)signed char ar_4[total]; // (поддерживается не всеми компиляторами)

* (+)float ar_3[sizeof(total) * 5];

* (+)short int ar_8[(int)(0.5 * 3)];

* (-)long long ar_6[0.5 * 2];

* (+)long double ar_7[TOTAL / 2];
 


