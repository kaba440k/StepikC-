**Подвиг 1.** Выберите все верные утверждения, касающиеся лямбда-выражений языка С++.

* (+)локальные переменные можно захватывать лямбда-выражением путем их копирования

* (+)локальные переменные можно захватывать лямбда-выражением через механизм ссылок

* (+)через квадратные скобки лямбда-выражения можно передавать (захватывать) локальные переменные и использовать внутри лямбда-функции

* (-)глобальные идентификаторы (например, переменные) также нужно захватывать, чтобы они стали доступны внутри лямбда-выражения

* (+)локальные переменные можно захватывать лямбда-выражением через указатели

* (+)глобальные идентификаторы (например, переменные) всегда доступны внутри лямбда-выражения


**Подвиг 2.** Выберите все верные утверждения, касающиеся захвата переменных лямбда-выражениями.

* (-)при захвате массива int d[10]; [d] ([параметры]) mutable {[операторы]} изменение значений его элементов в лямбда-функции приведет также к изменению внешнего массива d

* (+)выражение вида [=]([параметры]) {[операторы]} позволяет в теле лямбда-функции только читать значения из копий любых локальных переменных

* (+)при захвате массива int d[10]; [d] ([параметры]) mutable {[операторы]} изменение значений его элементов в лямбда-функции не приведет к изменению внешнего массива d

* (+)выполнение выражение вида [var_i]([параметры]) {var_i += 1;} приведет к ошибке, т.к. переменная var_i является константной

* (-)выполнение выражение вида [a, b] ([параметры]) mutable { a++; --b; } приведет к изменению переменных a и b и это изменение затронет внешние локальные переменные a и b

* (+)выполнение выражение вида [a, b] ([параметры]) mutable { a++; --b; } приведет к изменению переменных a и b только внутри лямбда-функции и не затронет внешние локальные переменные a и b


**Подвиг 3.** Выберите все верные утверждения, касающиеся захвата переменных лямбда-выражениями.


* (-)выполнение выражение вида [&var_i]([параметры]) {var_i += 1;} приведет к ошибке, т.к. переменная var_i является константной ссылкой

* (-)допустимо использовать запись вида [&, =] ([параметры]) {[операторы]}

* (+)выполнение выражение вида [&var_i]([параметры]) {var_i += 1;} приведет к изменению внешней переменной var_i

* (+)допустимо использовать запись вида [&, a, b] ([параметры]) {[операторы]}

* (+)выражение вида [&]([параметры]) {[операторы]} выполняет захват всех локальных переменных по ссылке

* (-)допустимо использовать запись вида [&, &a] ([параметры]) {[операторы]}

* (+)выполнение выражение вида [&var_i] ([параметры]) mutable {var_i += 1;} приведет к изменению внешней переменной var_i

* (+)допустимо использовать запись вида [=, &a, &b] ([параметры]) {[операторы]}


**Подвиг 4.** Пусть в программе имеются следующие локальные переменные:

char msg[] = "hello";
int count = 0;
int& lnk = count;
char* ptr = msg;

Выберите все верные (работающие) варианты объявления лямбда-выражений.

* (+)auto lmd_4 = [&lnk] (int step) { lnk += step; };

* (+)auto lmd_1 = [msg, count, lnk, ptr] () { return count + 1; };

* (-)auto lmd_6 = [*ptr] (int step) { *ptr += step; };

* (+)auto lmd_3 = [&count] (int step) { count += step; };

* (-)auto lmd_7 = [lnk] (int step) { lnk += step; };

* (+)auto lmd_5 = [ptr] (int step) { *ptr += step; };

* (+)auto lmd_2 = [=] () { std::cout << msg; };


**Подвиг 5.** Выберите все верные утверждения, связанные со следующей программой:

#include <iostream>

int main(void)
{
    int count = 1;
    int& lnk = count;

    auto r = [lnk] (int step) mutable { lnk += step; };

    r(5);
    std::cout << count << std::endl;

    return 0;
}


* (+)если в лямбда-выражении не указывать ключевое слово mutable, то переменная lnk была бы константной и неизменяемой

* (+)при захвате ссылки lnk в теле лямбда-выражения формируется переменная (не ссылка) lnk со значением 1

* (-)при захвате ссылки lnk в теле лямбда-выражения также формируется ссылка lnk на внешнюю переменную count

* (+)при выполнении программа выведет в консоль значение 1

* (-)при выполнении программа выведет в консоль значение 6


**Подвиг 9 (на повторение).** Выберите все верные объявления прототипов функций со значениями параметров по умолчанию.

* (-)void set_struct_data(int val, short pos = 0, double weight);

* (+)double normal(int mean, double sigma = 1.0);

* (-)bool is_fill(char fill = '0', const char* str);

* (+)short min_2(short a = 0, short b = 0);

* (-)unsigned rand_pos(unsigned a = 10, unsigned b);

* (+)void set_coords(int x, int y, int z = -1);

* (+)char* get_path(int count, const char sep='/', const char* path = "", const char *ext="");


**Подвиг 10 (на повторение).** Выберите все верные утверждения, касающиеся ссылок языка С++.

* (-)cсылки в С++ полностью заменяют собой традиционные указатели языка Си

* (+)ссылки - это безопасный инструмент, так как они могут быть связаны только с корректным lvalue-выражением (области памяти с данными)

* (+)ссылки - это, по сути, скрытый указатель, который хранит адрес переменной (lvalue-выражения), указанного при инициализации

* (+)ссылку можно воспринимать как второе имя переменной, с которой она связана (инициализирована)

* (+)ссылки удобно использовать при передаче объемных данных в параметры функций